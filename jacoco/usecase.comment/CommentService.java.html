<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommentService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">shareboard_is</a> &gt; <a href="index.source.html" class="el_package">usecase.comment</a> &gt; <span class="el_source">CommentService.java</span></div><h1>CommentService.java</h1><pre class="source lang-java linenums">package usecase.comment;

import model.entity.Comment;
import model.entity.CommentVote;
import model.entity.Post;
import model.entity.User;
import model.repository.CommentRepository;
import model.repository.GenericRepository;
import model.validation.CommentExists;
import model.validation.PostExists;
import usecase.auth.AuthenticationRequired;
import usecase.auth.AuthorizationException;
import usecase.auth.CurrentUser;
import usecase.auth.DenyBannedUsers;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.transaction.Transactional;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;
import java.time.Instant;
import java.util.List;
import java.util.Map;

import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.toList;

/**
 * Classe che fornisce i servizi relativi ai commenti.
 */
@ApplicationScoped
@Transactional
public class CommentService {
    private GenericRepository genericRepository;
    private CommentRepository commentRepo;
    private CurrentUser currentUser;

    private static final int MAX_COMMENT_DEPTH = 4;

<span class="nc" id="L40">    protected CommentService(){}</span>

    @Inject
    protected CommentService(GenericRepository genericRepository, CommentRepository commentRepository,
<span class="fc" id="L44">                                            CurrentUser currentUser){</span>
<span class="fc" id="L45">        this.genericRepository = genericRepository;</span>
<span class="fc" id="L46">        this.commentRepo = commentRepository;</span>
<span class="fc" id="L47">        this.currentUser = currentUser;</span>
<span class="fc" id="L48">    }</span>

    /**
     * Converte Comment in CommentDTO.
     * @param comment commento da convertire
     * @return commentDTO con i dati di comment
     */
    private CommentDTO map (Comment comment){
<span class="fc" id="L56">        CommentVote commentVote = null;</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if(currentUser.isLoggedIn()){</span>
<span class="nc" id="L58">            User user = genericRepository.findById(User.class, currentUser.getId());</span>
<span class="nc" id="L59">            commentVote = comment.getVote(user);</span>
        }

<span class="fc" id="L62">        return CommentDTO.builder()</span>
<span class="fc" id="L63">                .id(comment.getId())</span>
<span class="fc" id="L64">                .authorUsername(comment.getAuthor().getUsername())</span>
<span class="fc" id="L65">                .authorId(comment.getAuthor().getId())</span>
<span class="fc" id="L66">                .creationDate(comment.getCreationDate())</span>
<span class="fc" id="L67">                .postId(comment.getPost().getId())</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">                .vote(commentVote == null ? 0 : commentVote.getVote())</span>
<span class="fc" id="L69">                .content(comment.getContent())</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">                .votes(comment.getVotesCount() == null ? 0 : comment.getVotesCount())</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                .creationDate(comment.getCreationDate()  == null ? Instant.now() : comment.getCreationDate())</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">                .parentCommentId(comment.getParentComment() == null ? 0 : comment.getParentComment().getId())</span>
<span class="fc" id="L73">                .build();</span>
    }

    /**
     * Ritorna una mappa la cui chiave è l'id del commento padre e il valore una lista di CommentDTO
     * @param postId l'id di un post esistente di cui si vuole ottenere i commenti
     * @return mappa con i commenti del post
     */
    public Map&lt;Integer,List&lt;CommentDTO&gt;&gt; getPostComments(@PostExists int postId){
<span class="nc" id="L82">        List&lt;Comment&gt; comments = commentRepo.getByPost(genericRepository.findById(Post.class, postId), MAX_COMMENT_DEPTH);</span>
<span class="nc" id="L83">        return comments.stream().map(this::map).collect(groupingBy(CommentDTO::getParentCommentId, toList()));</span>
    }

    /**
     * Ritorna una mappa la cui chiave è l'id del commento padre e il valore una lista di CommentDTO
     * @param commentId l'id di un commento esistente di cui si vuole ottenere le risposte
     * @return mappa con le risposte al commento
     */
    public Map&lt;Integer, List&lt;CommentDTO&gt;&gt; getReplies(@CommentExists int commentId){
<span class="nc" id="L92">        List&lt;Comment&gt; comments = commentRepo.getReplies(genericRepository.findById(Comment.class, commentId), MAX_COMMENT_DEPTH);</span>
<span class="nc" id="L93">        return comments.stream().map(this::map).collect(groupingBy(CommentDTO::getParentCommentId, toList()));</span>
    }

    /**
     * Ritorna un commento dato il suo id
     * @param id l'id di un commento esistente
     * @return commento avente l'id specificato
     */
    public CommentDTO getComment(@CommentExists int id){
<span class="fc" id="L102">        return map(genericRepository.findById(Comment.class, id));</span>
    }


    /**
     * Cancella un commento dato il suo id
     * @param id l'id di un commento esistente
     */
    @AuthenticationRequired
    public void delete(@CommentExists int id){
<span class="fc" id="L112">        Comment comment = genericRepository.findById(Comment.class, id);</span>
<span class="fc bfc" id="L113" title="All 4 branches covered.">        if(currentUser.getId() != comment.getAuthor().getId() &amp;&amp; !currentUser.isAdmin())</span>
<span class="fc" id="L114">            throw new AuthorizationException();</span>
<span class="fc" id="L115">        genericRepository.remove(genericRepository.findById(Comment.class, id));</span>
<span class="fc" id="L116">    }</span>

    /**
     * Modifica un commento dato il suo id
     * @param id l'id di un commento esistente
     * @param text stringa con testo da sostituire
     */
    @AuthenticationRequired
    public void editComment(@CommentExists int id, @NotBlank @Size(max=65535) String text){
<span class="fc" id="L125">        Comment comment = genericRepository.findById(Comment.class, id);</span>
<span class="fc bfc" id="L126" title="All 4 branches covered.">        if(currentUser.getId() != comment.getAuthor().getId() &amp;&amp; !currentUser.isAdmin())</span>
<span class="fc" id="L127">            throw new AuthorizationException();</span>
<span class="fc" id="L128">        comment.setContent(text);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Crea un nuovo commento e ne restituisce l'id
     * @param text una stringa non vuota di massimo 65535 caratteri
     * @param postId id di un post esistente
     * @return id del commento creato
     */
    @AuthenticationRequired
    @DenyBannedUsers
    public int newComment(@NotBlank @Size(max=65535) String text,
                          @PostExists int postId){
<span class="fc" id="L141">        User user = genericRepository.findById(User.class, currentUser.getId());</span>

<span class="fc" id="L143">        Comment comment = new Comment();</span>
<span class="fc" id="L144">        comment.setAuthor(user);</span>
<span class="fc" id="L145">        comment.setContent(text);</span>
<span class="fc" id="L146">        comment.setPost(genericRepository.findById(Post.class, postId));</span>
<span class="fc" id="L147">        return genericRepository.insert(comment).getId();</span>
    }

    /**
     * Crea una risposta a un commento e ne restituisce l'id
     * @param text una stringa non vuota di massimo 1000 caratteri
     * @param parentCommentId id di un commento esistente
     * @return id del commento creato
     */
    @AuthenticationRequired
    public int newCommentReply(@NotBlank @Size(max=65535) String text,
                               @CommentExists int parentCommentId){
<span class="fc" id="L159">        User user = genericRepository.findById(User.class, currentUser.getId());</span>
<span class="fc" id="L160">        Comment parent = genericRepository.findById(Comment.class, parentCommentId);</span>

<span class="fc" id="L162">        Comment comment = new Comment();</span>
<span class="fc" id="L163">        comment.setAuthor(user);</span>
<span class="fc" id="L164">        comment.setContent(text);</span>
<span class="fc" id="L165">        comment.setPost(parent.getPost());</span>
<span class="fc" id="L166">        comment.setParentComment(parent);</span>
<span class="fc" id="L167">        return genericRepository.insert(comment).getId();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>